from kivy.app import App
from kivy.uix.label import Label
from kivy.uix.gridlayout import GridLayout
from kivy.uix.scrollview import ScrollView
from kivy.uix.anchorlayout import AnchorLayout
from kivy.uix.popup import Popup
from kivy.uix.textinput import TextInput
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.core.window import Window
from WorkWithDB import create_table, transfer_in_array, add_new_key, dell_key
import requests
from web3 import Web3

Window.size = (350, 600)
Window.clearcolor = (10 / 255, 10 / 255, 10 / 255, 1)
Window.title = "MultiWallet"

create_table()
global wallets
wallets = transfer_in_array()
global layout
global popup_add_private_key


class WalletsCatalog(App):
    def __init__(self, **kwargs):
        super(WalletsCatalog, self).__init__(**kwargs)
        self.wallet_input = str()
        self.popup_add_private_key = None
        self.wallet_layout = GridLayout(cols=1, spacing=10, size_hint_y=None)
        self.wallet_layout.bind(minimum_height=self.wallet_layout.setter('height'))

    def refresh_table(self):
        self.wallet_layout.clear_widgets()
        for wallet in wallets:
            button = Button(text=wallet, size_hint=(1, None), height=40,
                            background_color=(50 / 255, 205 / 255, 50 / 255, 1))
            button.bind(on_press=self.on_wallet_click)
            self.wallet_layout.add_widget(button)

    def create_popup_add_private_key(self):
        content = BoxLayout(orientation='vertical', spacing=10)
        text_input_layout = AnchorLayout(anchor_y='top')
        content.add_widget(text_input_layout)
        text_input = TextInput(text='close_key', size_hint=(1, 0.2))
        text_input.bind(text=self.on_text_input)
        text_input_layout.add_widget(text_input)
        button_add = Button(text="ADD", size_hint=(1, 0.2))
        button_add.bind(on_press=self.on_add_button_press)
        content.add_widget(button_add)
        self.popup_add_private_key = Popup(title='Enter close key',
                                            size_hint=(0.7, 0.5), content=content)

    def on_text_input(self, instance, value):
        self.wallet_input = value

    def on_add_button_press(self, instance):
        add_new_key(self.wallet_input)
        wallets.append(self.wallet_input)
        self.refresh_table()
        self.popup_add_private_key.dismiss()

    def build(self):
        main_layout = BoxLayout(spacing=10, orientation='vertical')
        self.refresh_table()
        scrollview = ScrollView(size_hint=(1, 7), size=(Window.width, Window.height))
        scrollview.add_widget(self.wallet_layout)
        main_layout.add_widget(scrollview)
        bottom_layout = BoxLayout(spacing=10, orientation='horizontal')
        button_add = Button(text="ADD")
        button_add.bind(on_press=self.show_popup_add_private_key)
        bottom_layout.add_widget(button_add)
        button_dell = Button(text="DELL")
        button_dell.bind(on_press=self.on_dell_button_press)
        bottom_layout.add_widget(button_dell)
        main_layout.add_widget(bottom_layout)
        return main_layout

    def show_popup_add_private_key(self, instance):
        self.create_popup_add_private_key()
        self.popup_add_private_key.open()

    def on_dell_button_press(self, instance):
        print('')

    def on_wallet_click(self, instance):
        self.stop()
        WalletManager().run()


class WalletManager(App):
    def build(self):
        label = Label(text="TEST")
        return label


if __name__ == "__main__":
    WalletsCatalog().run()

# class CryptoWork:
#     def get_eth_price_from_bybit(self):
#         response = requests.get('https://api.bybit.com/derivatives/v3/public/tickers?symbol=ETHUSDT&limit=1')
#         return (response.json()['result']['list'][0]['lastPrice'])
#
#     def get_eth_balance_from_wallet(self, private_key, rpc):
#         w3 = Web3(Web3.HTTPProvider(rpc))
#         account = w3.eth.account.from_key(private_key)
#         address = account.address
#         balance = w3.eth.get_balance(address)
#         return balance
#
#     def get_address_from_private_key(self, private_key, rpc):
#         w3 = Web3(Web3.HTTPProvider(rpc))
#         account = w3.eth.account.from_key(private_key)
#         address = account.address
#         return address
#
#     def send_eth(self, key_from, address_to, eth_amount):
#         web3 = Web3(Web3.HTTPProvider("https://arbitrum.drpc.org"))
#         account = web3.eth.account.from_key(private_key=key_from)
#         nonce = web3.eth.get_transaction_count(account.address, 'pending')
#         gas_estimate = web3.eth.estimate_gas({
#             'to': address_to,
#             'value': web3.to_wei(eth_amount, 'ether'),
#         })
#
#         transaction = {
#             'nonce': nonce,  # Добавляем nonce сюда
#             'to': address_to,
#             'value': web3.to_wei(eth_amount, 'ether'),
#             'gas': gas_estimate,
#             'gasPrice': web3.eth.gas_price,
#         }
#
#         print(web3.from_wei(transaction['gas'],'ether'))
#         signed_txn = web3.eth.account.sign_transaction(transaction, key_from)
#
#         txn_hash = web3.eth.send_raw_transaction(signed_txn.rawTransaction)
#
#         return txn_hash.hex()
#
#
#     # scan - example - etherscan,arbiscan
#     # address - кошелек для которого нужно сканить
#     # api_key - брал для арбитрума, для эфира не тестил
#     def get_transactions_history(self, scan, address, api_key='272WETQQ4WRRUVBINPZRXBWPRE2G4G4SE8'):
#         response = requests.get(
#             f'https://api.{scan}.io/api?module=account&action=txlist&address={address}&startblock=0&endblock=latest&sort=asc&page=1&offset=10&apikey={api_key}')
#         # потом обработать транзакции
#         return response.json()['result']
#
# test = CryptoWork()
#
# print(test.send_eth("043197848fd07c11cc5b6649a6756aa5fe4f22090c1e38b69cdb14d9fcb84f73","0x8500d1bff3D261F11E48d1A5F83eF08735e80B09",0.00000001))
